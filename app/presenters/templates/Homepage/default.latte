{block style}
	<style>
		@-moz-document url-prefix() {
			#calc-select {
				text-indent: 0.25em;
			}
		}

		#calc-checkbox-wrapper {
			background-color: #282828;
			border: 4px solid rgb(107, 110, 115);
		}

		#calc-checkbox {
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			width: 1.5em;
			height: 1.5em;
			border: 4px solid rgb(107, 110, 115);
			border-radius: 9px;
			background-color: #282828;
		}

		#calc-checkbox:checked {
			background-color: rgb(91, 51, 120);
		}

		#orbitals-table tr:nth-of-type(2n+1) td, #orbitals-table th {
			border: 5px solid;
			border-image: linear-gradient(0deg, rgba(0, 0, 0, 1) 0%, rgba(134, 134, 134, 1) 50%, rgba(0, 0, 0, 1) 100%) 35%;
		}

		.valence {
			background-color: rgb(91, 51, 120);
		}

		.canvas {
			border-radius: 10px;
			background-color: rgba(0, 0, 0, 0.7);
		}

		.arrow-wrap {
			height: calc(1.5em + 12px);
			padding: 3px;
		}

		.canvas:hover, #orbitals-table tbody tr:nth-of-type(2n+1):hover {
			cursor: pointer;
		}

		#orbitals-table tbody tr:nth-of-type(2n+1):hover {
			box-shadow: 0 0 25px 5px #ddd;
		}

		.renderer {
			top: 0;
			left: 0;
		}

		.hide-icon {
			transform: rotate(180deg);
		}

		.btn-fullscreen {
			right: 0.5em;
			bottom: 0.5em;
			height: 40px;
		}

		.m-toolbar {
			background-color: #707070;
			border-radius: 10px;
		}

		.m-toolbar label {
			background-color: #252525;
			border-radius: 10px;
			cursor: pointer;
		}

		.m-toolbar input[type="radio"]:checked + label {
			background-color: #fff;
			border: 4px solid #252525;
			color: #252525;
		}
	</style>
{/block}

{block content}
	<div id="app">
		<form id="calc-form" @submit.prevent="calculate">
			<div class="row justify-content-center">
				<div class="col-12 text-center">
					Check this out!
				</div>
				<div class="col-12 col-md-6 col-lg-4 mt-2">
					<input v-model.number="inputNumber" @focus="$event.target.select()" id="calc-input" class="w-100" type="number"
						   placeholder="Proton number...">
				</div>
				<div class="col-12 col-md-4 col-lg-3 mt-2">
					<select v-model="inputNumber" ref="elementSelect" id="calc-select" class="w-100 h-100 p-1">
						<option value="">Z</option>
						<option v-for="element in elements" :value="element[0]">{{ element[1] }}</option>
					</select>
				</div>
				<div class="col-12 col-md-6 col-lg-4 mt-2">
					<div id="calc-checkbox-wrapper" class="text-center p-1">
						<input v-model="inputShort" id="calc-checkbox" class="align-top" type="checkbox">
						<label class="mb-0 ml-2 align-top" for="calc-checkbox">
							<span>Show short</span>
						</label>
					</div>
				</div>
				<div class="col-12 col-md-4 col-lg-5 mt-2">
					<input id="calc-submit" type="submit" class="w-100 p-1" value="Calculate">
				</div>
			</div>
		</form>
		<div v-if="protonNumber" v-cloak class="row mt-3">
			<div class="col-12 text-center">
				<span v-if="showShort && nobleGasNumber > 0">[{{ elements[nobleGasIndex][1] }}] + </span>
				{{ elements[elementIndex][1] }}: {{ elements[elementIndex][2] }}
			</div>
			<div class="col-12">
				<table id="orbitals-table" class="w-100 text-center">
					<thead>
					<tr>
						<th>
							<span class="d-sm-none">Q#</span>
							<span class="d-none d-sm-inline d-md-none">Quantum #</span>
							<span class="d-none d-md-inline">Quantum number</span>
						</th>
						<th>Type</th>
						<th colspan="2">
							<span class="d-sm-none">e<sup>-</sup> #</span>
							<span class="d-none d-sm-inline">Electrons</span>
						</th>
					</tr>
					</thead>
					<tbody>
					<template v-for="(orbital, index) in displayOrbitals">
						<tr @click="toggleOpen(index, $event)" :class="valenceIndexes.includes(index) ? 'valence' : ''">
							<td>{{ orbital.n }}</td>
							<td>{{ getOrbitalTypeText(orbital.type) }}</td>
							<td>{{ orbital.electronNumber }}</td>
							<td>
								<div class="arrow-wrap">
									<img :src="getRowIconAddress(opened !== index)" class="h-100 hide-icon" alt="expand plus button or hide button">
								</div>
							</td>
						</tr>
						<tr :class="{'d-none': opened !== index}">
							<td colspan="4" class="container-fluid">
								<form class="m-toolbar mt-3 p-1">
									Magnetic number<br>
									<template v-for="(m, i) in getOrientations(orbital.type)">
										<input v-model="mS[getPrincipleIndex(index)]" :value="m" :id="'radio' + index + '-' + i" class="d-none" type="radio">
										<label :for="'radio' + index + '-' + i" class="d-inline-block m-0 px-2 py-0">{{ m }}</label>
									</template>
								</form>
								<div @click.stop="addModel(index, $event)" class="canvas row overflow-hidden position-relative mx-auto mt-2 mb-2 pt-2 pb-2">
									<div @click="enableKeys(index)" class="renderer invisible position-absolute w-100 h-100">
										<div class="position-absolute" style="color: #f00;"></div>
										<img @click="toggleFullscreen(index)" class="btn-fullscreen position-absolute" :src="getFullscreenIconAddress(index)" alt="open or close fullscreen">
									</div>
									<template v-if="!models.includes(index) && isWebGLAvailable">
										<div class="col-6">
											<svg height="70%" width="80%" class="position-relative verticalHorizontalAlign" viewBox="0 0 91 104" xmlns="http://www.w3.org/2000/svg">
												<polygon stroke="#ddd" stroke-width="4px" stroke-linejoin="round" fill="none" points="2,2 2,102 89,52"></polygon>
											</svg>
										</div>
										<div class="col-6">
											<div class="position-relative verticalHorizontalAlign">
												Show 3D model of orbital.
											</div>
										</div>
									</template>
									<template v-else-if="isWebGLAvailable">
										<div class="col-12">
											<div class="position-relative verticalHorizontalAlign">
												This will take a moment...
											</div>
										</div>
									</template>
									<template v-else>
										<div class="col-12">
											<div class="position-relative verticalHorizontalAlign">
												Your browser doesn't support WebGL.
											</div>
										</div>
									</template>
								</div>
							</td>
						</tr>
					</template>
					</tbody>
				</table>
			</div>
		</div>
	</div>
{/block}

{block script}
	<script>
		function isWebGLAvailable() {
			try {
				let canvas = document.createElement('canvas')
				return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')))
			} catch (e) {
				return false
			}
		}

		class Visualization {
			constructor(element) {
				this.renderEl = element
				this.frames = 0
				this.lastTime = -1
				this.continue = true
				this.isFullscreen = false
				this.currentIndex = 0
				this.maxIndex = 25
				this.frameRates = new Array(this.maxIndex + 1)
				this.averageFrameRate = null
				this.needsDownsize = 0
				this.needsUpsize = 0
				this.width = this.renderEl.clientWidth
				this.height = this.renderEl.clientHeight

				// arrow function to keep reference of this to current object
				this.animate = (time) => {
					this.renderer.render(this.scene, this.camera)
					this.frames++

					if (this.currentIndex === this.maxIndex + 1) {
						this.currentIndex = 0
					}
					this.frameRates[this.currentIndex] = this.frames / (time - this.lastTime) * 1000
					this.currentIndex++
					this.averageFrameRate = Math.round(this.frameRates.reduce((sum, el) => sum + el) / this.frameRates.length)
					this.renderEl.children[0].innerHTML = this.averageFrameRate + ' FPS'

					if (this.averageFrameRate < 35) {
						this.needsDownsize++
						if (this.needsDownsize === this.maxIndex) {
							this.needsDownsize = 0
							let newWidth = this.width * 0.8
							if (Math.ceil(newWidth) >= this.renderEl.clientWidth / 2) {
								this.width = newWidth
								this.height = this.height * 0.8
								this.renderer.setSize(this.width, this.height, false)
							}
						}
					} else {
						this.needsDownsize = 0
					}

					if (this.averageFrameRate > 55) {
						this.needsUpsize++
						if (this.needsUpsize === this.maxIndex) {
							this.needsUpsize = 0
							let newWidth = this.width * 1.25
							if (Math.floor(newWidth) <= this.renderEl.clientWidth) {
								this.width = newWidth
								this.height = this.height * 1.25
								this.renderer.setSize(this.width, this.height, false)
							}
						}
					} else {
						this.needsUpsize = 0
					}

					if (time >= this.lastTime + 1000) {
						this.lastTime = time
						this.frames = 0
					}

					if (this.continue) {
						requestAnimationFrame(this.animate)
					}
				}
			}

			init(n, l, m, step, radius) {
				this.scene = new THREE.Scene();
				this.renderer = new THREE.WebGLRenderer({ antialias: true })
				this.renderer.setPixelRatio(window.devicePixelRatio)
				this.renderer.setSize(this.renderEl.clientWidth, this.renderEl.clientHeight, false)
				this.renderEl.appendChild(this.renderer.domElement)
				this.renderer.domElement.classList.add('w-100', 'h-100')
				this.camera = new THREE.PerspectiveCamera(40, this.renderEl.clientWidth / this.renderEl.clientHeight, 1, 1000)
				this.camera.position.set(15, 20, 30)
				this.scene.add(this.camera)
				this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement)
				this.scene.add(new THREE.AxesHelper(20))

				window.addEventListener('resize', () => {
					this.onWindowResize()
				}, false)

				this.prepareScene(n, l, m, step, radius)

				this.animate(0)
			}

			prepareScene(n, l, m, step, radius) {
				let geometry = new THREE.BufferGeometry()
				let colors = []

				let [positions, info] = schrodinger(n, l, m, step, radius)

				for (let i of info) {
					colors.push(i, 0, 1)
				}

				geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3))
				geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3))

				let material = new THREE.PointsMaterial({ size: 1, vertexColors: THREE.VertexColors })
				let points = new THREE.Points(geometry, material)

				this.scene.add(points)
			}

			onWindowResize() {
				this.width = this.renderEl.clientWidth
				this.height = this.renderEl.clientHeight
				this.renderer.setSize(this.width, this.height, false)
				this.camera.aspect = this.width / this.height
				this.camera.updateProjectionMatrix()
			}

			openFullscreen() {
				if (this.renderEl.requestFullscreen) {
					this.renderEl.requestFullscreen()
				} else if (this.renderEl.mozRequestFullScreen) {
					this.renderEl.mozRequestFullScreen()
				} else if (this.renderEl.webkitRequestFullscreen) {
					this.renderEl.webkitRequestFullscreen()
				} else if (this.renderEl.msRequestFullscreen) {
					this.renderEl.msRequestFullscreen()
				}
			}
		}
	</script>
	<script>
		sortElements()

		function setHeight(el) {
			let styles = getComputedStyle(el)
			if (window.innerHeight > window.innerWidth) {
				el.style.height = styles.width
			} else {
				el.style.height = styles.height
			}
		}

		function closeFullscreen() {
			if (document.exitFullscreen) {
				document.exitFullscreen()
			} else if (document.mozCancelFullScreen) {
				document.mozCancelFullScreen()
			} else if (document.webkitExitFullscreen) {
				document.webkitExitFullscreen()
			} else if (document.msExitFullscreen) {
				document.msExitFullscreen()
			}
		}

		let keysFlag = false

		var app = new Vue({
			el: '#app',
			data() {
				return {
					inputNumber: '',
					protonNumber: 0,
					electronNumber: 0,
					opened: null,
					hash: '',
					models: [],
					visualizations: [],
					isWebGLAvailable: isWebGLAvailable(),
					mS: [],
					inputShort: true,
					showShort: true,
				}
			},
			computed: {
				orbitals: function () {
					let element = new Element(this.protonNumber)
					let mainQuantum = new QuantumLayer(1)
					let controller = new Controller(element, mainQuantum, exceptions)
					controller.initiate()
					controller.checkExceptions()
					return element.orbitals.filter(orbital => orbital.electronNumber > 0)
				},
				elementIndex: function () {
					return elements.findIndex((e) => e[0] === this.protonNumber)
				},
				valenceIndexes: function () {
					return getValenceIndexes(this.displayOrbitals, this.protonNumber, ranges, layers).filter(index => index !== -1)
				},
				shortOrbitals: function () {
					let lastNobleGas
					for (let i = nobleGases.length - 1; i >= 0; i--) {
						if (nobleGases[i] < this.protonNumber) {
							lastNobleGas = nobleGases[i]
						}
					}
					let seekedLayer = 1 + (typeof lastNobleGas === 'undefined' ? 0 : layers.findIndex(array => array.includes(this.protonNumber)))
					return this.orbitals.filter(function (orbital) {
						if (orbital.n === seekedLayer && (orbital.type === 0 || orbital.type === 1)) {
							return true
						} else if (orbital.n === seekedLayer - 1 && orbital.type === 2) {
							return true
						} else if (orbital.n === seekedLayer - 2 && orbital.type === 3) {
							return true
						} else {
							return false
						}
					})
				},
				displayOrbitals: function () {
					if (this.showShort) {
						return this.shortOrbitals
					} else {
						return this.orbitals
					}
				},
				nobleGasNumber: function () {
					for (let i = nobleGases.length; 0 <= i; i--) {
						if (nobleGases[i] < this.protonNumber) {
							return nobleGases[i]
						}
					}

					return -1
				},
				nobleGasIndex: function () {
					return elements.findIndex(el => el[0] === this.nobleGasNumber)
				},
			},
			methods: {
				getPrincipleIndex: function (i) {
					let orbital = this.displayOrbitals[i]
					return mathModel(orbital.n, orbital.type)
				},
				calculate: function () {
					if (this.inputNumber < 1 || this.inputNumber > maxProtonNumber) {
						alert(`Proton number must be bigger than 0 and smaller than ${ maxProtonNumber + 1 }.`)
					} else if (this.inputNumber !== Math.floor(this.inputNumber)) {
						alert('Proton number must be an integer not a float.')
					} else {
						this.protonNumber = this.inputNumber
						this.electronNumber = this.inputNumber
						window.location.hash = '#' + this.protonNumber
						this.showShort = this.inputShort
					}
				},
				toggleOpen: function (i, ev) {
					let index = this.getPrincipleIndex(i)
					if (this.opened !== null) {
						let openedIndex = this.getPrincipleIndex(this.opened)
						if (typeof this.visualizations[openedIndex] !== 'undefined') {
							this.visualizations[openedIndex].continue = false
						}
					}
					if (this.opened === i) {
						this.opened = null
					} else {
						this.opened = i
						if (typeof this.visualizations[index] !== 'undefined') {
							this.visualizations[index].continue = true
							this.visualizations[index].animate(0)
						}

						let el = ev.currentTarget.nextElementSibling
						let canvas = el.querySelector('.canvas')
						this.$nextTick(function () {
							setHeight(canvas)

							let bottom = el.getBoundingClientRect().bottom
							if (bottom > window.innerHeight) {
								window.scrollTo({
									top: document.documentElement.scrollTop + bottom - window.innerHeight,
									behavior: 'smooth'
								})
							}
						})
					}
				},
				addModel: function (i, ev) {
					keysFlag = true
					let orbital = this.displayOrbitals[i]
					let index = mathModel(orbital.n, orbital.type)
					if (!this.models.includes(index) && this.isWebGLAvailable) {
						this.models.push(index)
						let visualizationElement = ev.currentTarget.children[0]

						// use instead of $nextTick to force browser to repaint and show user wait message
						// Google search: double requestAnimationFrame
						requestAnimationFrame(() => {
							requestAnimationFrame(() => {
								this.changeVisualization(visualizationElement, index, orbital.n, orbital.type, this.mS[index], 0.1, 0.2)
							})
						})
					}
				},
				changeVisualization: function (element, index, n, l, m, step, radius) {
					let visualization = new Visualization(element)
					visualization.init(n, l, m, step, radius)
					element.style.zIndex = '1'
					element.classList.remove('invisible')
					this.$set(this.visualizations, index, visualization)
				},
				enableKeys: function (i) {
					let index = this.getPrincipleIndex(i)
					if (true) {
						this.visualizations[index].controls.enableKeys = true
					}
				},
				getRowIconAddress: function (show) {
					return {$basePath} + '/assets/' + (show ? 'plus' : 'hide') + '.svg'
				},
				getFullscreenIconAddress: function (index) {
					return {$basePath} + '/assets/' + (typeof this.visualizations[index] !== 'undefined' && this.visualizations[index].isFullscreen ? 'close' : 'open') + '-fullscreen.svg'
				},
				toggleFullscreen: function (i) {
					let index = this.getPrincipleIndex(i)
					if (this.visualizations[index].isFullscreen) {
						closeFullscreen()
					} else {
						this.visualizations[index].isFullscreen = true
						this.visualizations[index].openFullscreen()
					}
				},
			},
			beforeMount() {
				this.hash = window.location.hash
			},
			watch: {
				hash: function () {
					let afterHash = parseInt(this.hash.substring(1))
					if (afterHash > 0 && afterHash <= maxProtonNumber) {
						this.protonNumber = this.inputNumber = afterHash
					}
				},
				orbitals: function () {
					let maxIndex = 0
					for (let orbital of this.orbitals) {
						let tmp = mathModel(orbital.n, orbital.type)
						if (tmp > maxIndex) {
							maxIndex = tmp
						}
					}
					this.mS = (new Array(maxIndex + 1)).fill(0)
				},
				mS: function () {
					if (this.opened !== null) {
						let openedIndex = this.getPrincipleIndex(this.opened)
						if (typeof this.visualizations[openedIndex] !== 'undefined') {
							let element = this.visualizations[openedIndex].renderEl
							element.querySelector('canvas').remove()
							let orbital = this.displayOrbitals[this.opened]
							element.style.zIndex = 'auto'
							element.classList.add('invisible')
							this.changeVisualization(element, openedIndex, orbital.n, orbital.type, this.mS[openedIndex], 0.1, 0.2)
						}
					}
				},
			},
		})

		window.addEventListener('popstate', function () {
			app.hash = window.location.hash
		})
		window.addEventListener('click', function () {
			if (keysFlag) {
				for (let visualization of app.visualizations) {
					if (typeof visualization !== 'undefined') {
						visualization.controls.enableKeys = false
					}
				}
				keysFlag = false
			}
		})
		window.addEventListener('fullscreenchange', function () {
			let openedIndex = app.getPrincipleIndex(app.opened)
			if (document.fullscreenElement === null) {
				app.visualizations[openedIndex].isFullscreen = false
			}
			app.visualizations[openedIndex].onWindowResize()
		})
	</script>
{/block}
